Resumo da aula 07 (18/04)  --- depois de uma Santa Semana!
-------------------------


=======================
Problema 12: Dado um número inteiro n, n>0, verificar se n é primo.
Obs: o número 1, por definição, não é primo.


  int n, div ;
  int e_primo ;

  printf("Digite n (n>0): ") ;
  scanf("%d", &n) ;

  eh_primo = 1 ;  /* começar supondo que n é primo */

  /* a ideia consiste em tentar verificar se n é
     divisível por algum divisor, começando em 2
     e indo até o maior divisor para o qual faz
     sentido fazer a verificação */
  div = 2 ;
  while (div*div <= n && eh_primo) {
      if (n%div == 0) {   /* div é divisor de n */
          eh_primo = 0 ;
      }
      else {
          div = div + 1 ;
      }
  }

  if (eh_primo) {
      printf("O número %d é primo\n", n) ;
  }
  else {
      printf("O número %d não é primo\n", n) ;
  }


Vejamos:
- "div*div <= n" é uma forma de dizer se o divisor
  é menor ou igual à raiz quadrada de n (o maior divisor
  para o qual faze sentido fazer a verificação).
  Escrevemos assim pois não sabemos como calcular
  a raiz quadrada (ainda)
  
- Se n==2 ou n==3, o programa não entrará no laço
  e responderá que "n é primo". Está correto.
  
- Se n>3, e se for par, na primeira iteração do laço
  a verificação n%2 == 0 será verdadeira e o laço será
  interrompido em seguida com eh_primo valendo zero.
  A resposta certa será impressa.
  Se n for ímpar, enquanto div for menor ou igual à raiz
  quadrada de n e nenhum div testado for divisor de n,
  o laço será repetido, aumentando-se o valor de div um
  por um. Se algum número for divisor exato de n,
  significa que n tem um divisor próprio >=2 e <n e a flag
  eh_primo recebe valor zero. Neste caso, n não
  é primo e a resposta correta será impressa.
  Por outro lado, o laço pode terminar pois o valor
  de div atinge o valor máximo para o qual faz sentido
  fazer a verificação. Neste caso será impressa que
  n é primo. Resultado também correto

- faltou o caso n==1. Neste caso, vai acontecer a
  mesma coisa que acontece com n=2 e n=3. O programa
  vai imprimir que 1 é primo. Mas esta resposta está
  ERRADA!!
  Às vezes temos algum caso extremo que não segue um
  padrão. Nesses casos, em vez de ficar buscando um
  jeito mágico de enquadrá-lo, tratar ele à parte pode
  ser a solução mais simples.

  Poderíamos alterar a inicialização da variável
  eh_ primo da seguinte forma:

  if (n > 1) {
      eh_primo = 1 ;
  }
  else {
      eh_primo = 0 ;
  }

  O restante segue da mesma forma!


=======================
Problema 13: Dizemos que um número inteiro positivo é triangular se ele é
o produto de três números inteiros consecutivos. Por exemplo, 120 é triangular,
pois 4*5*6 é igual a 120. Dado um número inteiro positivo n, verificar se n
é triangular.


Solução usando bandeira
-----------------------

  int n, x ;
  int eh_triangular ;
  
  printf("Digite n (n>0): ") ;
  scanf("%d", &n) ;

  eh_triangular = 0 ;
  x = 1 ;
  while ((!eh_triangular) &&  (x*(x+1)*(x+2) <= n) ) {
      if (x*(x+1)*(x+2) == n) {
          eh_triangular = 1;
      }
      else {
          x = x + 1 ;
      }
  }

  if (eh_triangular) {
      printf("O número %d é triangular pois %d = %d*%d*%d\n", n, n, x, x+1, x+2) ;
  }
  else {
      printf("O número %d não é triangular\n", n) ;
  }

  

Sem usar bandeira! ---------------------------
  int n, x ;
  
  printf("Digite n (n>0): ") ;
  scanf("%d", &n) ;

  x = 1 ;
  
  while ( x*(x+1)*(x+2) < n ) {
     x = x + 1 ;

  if (x*(x+1)*(x+2) == n) {
      printf("O número %d é triangular pois %d = %d*%d*%d\n", n, n, x, x+1, x+2) ;
  }
  else {
      printf("O número %d não é triangular\n", n) ;
  }


======================================
Problema 14: EX3
Dado um número inteiro n, n > 1, imprimir sua decomposição em
fatores primos, indicando também a mutiplicidade de cada fator.
Por exemplo, para n = 600, a saída deverá ser:
   fator 2 multiplicidade 3
   fator 3 multiplicidade 1
   fator 5 multiplicidade 2


======================================
Problema 15: Dados n, n>0, e uma sequência de n números inteiros,
determinar quantos segmentos de números iguais consecutivos compõem
essa sequência.

Exemplo: A sequência   5  2  2  3  4  4  4  4  1  1  3  3 ,
com n=12 elementos, é formada por 6 segmentos de números iguais

int main() {
    int n, nseg, ant, prox ;

    printf("Digite n (n>0): ");
    scanf("%d", &n) ;

    printf("Digite os números da sequência: ");
    scanf("%d", &ant) ;
    nseg = 1 ;
    n = n - 1 ;

    while (n>0) {
    	 scanf("%d", &prox) ;
 	 if (ant != prox) {
             nseg = nseg+1;
	     ant = prox ;
	 }
	 n = n - 1 ;
    }
    printf("Há %d segmentos de números iguais na sequência\n", nseg);
    return 0 ;
}


======================================
Problema 16: Dados dois números inteiros positivos, determinar
o máximo divisor comum entre eles usando o algoritmo de Euclides.

Exemplo: mdc(24,15) = 3

    24/15 ==>  q=1  e  resto=9
    15/9  ==>  q=1  e  resto=6
    9/6   ==>  q=1  e  resto=3
    6/3   ==>  q=2  e  resto=0  ===> logo, mdc(24,15)=3


int main() {
    int a, b, resto ;

    printf("Digite a e b positivos: ");
    scanf("%d %d", &a, &b) ;

    resto = a % b ;
    
    while (resto != 0) {
         a = b ;
	 b = resto ;
	 resto = a % b ;
    }
    printf("O mdc é  %d\n", b) ;
        return 0 ;
}


Vejamos: para o exemplo acima, antes do laço, resto=9
Na primeira iteração, a=15, b=9 e resto=6
Na segunda iteração, a=9, b=6 e resto=3
Na terceira iteração, a=6, b=3 e resto=0
Sai da iteração e imprime 3

Agora suponha que a=15 e b=24
r=15, inicialmente
Na primeira iteração, a=24, b=15 e r=9
Na segunda iteração, a=15, b=9 e r=6
Ooops, ficou igual à primeira iteração do caso acima!


